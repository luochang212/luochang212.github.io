<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Chang Luo</title>
    <link>https://luochang212.github.io/categories/algorithms/</link>
    <description>Recent content in Algorithms on Chang Luo</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 19 Apr 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luochang212.github.io/categories/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DNN 模型聚类特征更新方法</title>
      <link>https://luochang212.github.io/posts/cluster_label_assign/</link>
      <pubDate>Sat, 19 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/cluster_label_assign/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本文探讨如何在 DNN 模型中天级更新聚类特征时，保持聚类标签的稳定性。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/label-assignment&#34; target=&#34;_blank&#34;&gt;label-assignment&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文的主要内容包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;BLIP-2&lt;/code&gt; 将图片转为 embedding&lt;/li&gt;&#xA;&lt;li&gt;使用匈牙利算法建立重训练标签到原标签的映射&#xA;&lt;ul&gt;&#xA;&lt;li&gt;开发以 &lt;strong&gt;样本重合率&lt;/strong&gt; 为度量的方法&lt;/li&gt;&#xA;&lt;li&gt;开发以 &lt;strong&gt;类心距离&lt;/strong&gt; 为度量的方法&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;赋予 embedding 近似聚类 ID 的方法：最近邻法&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;时至今日，多塔模型仍以 ID 类特征为主。将模型特征以 raw data 的形式直接送入模型，效果往往不好。因此，我们通常先将特征 ID 化，然后用 &lt;code&gt;mmh3&lt;/code&gt; 哈希打散后，再送入模型。其中，&lt;strong&gt;特征 ID 化&lt;/strong&gt; 是一个重要步骤，如果 ID 的粒度太细，细到极致相当于每个样本一个 ID，这时样本就无法和与之相似的样本通过 ID 进行交互；如果 ID 的粒度太粗，则 ID 下的样本过多，此时模型无法从中学到指向足够明确的信息。&lt;/p&gt;&#xA;&lt;p&gt;将模型特征 ID 化有很多方法，比如 聚类（无监督）、分类（有监督）、量化等等。本文仅讨论 &lt;strong&gt;聚类算法&lt;/strong&gt; 及其在深度学习模型中的应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;一引子频繁变更索引的代价&#34;&gt;一、引子：频繁变更索引的代价&lt;/h2&gt;&#xA;&lt;p&gt;为了理解聚类算法产生的聚类 ID 是如何在深度模型中发生作用的，有必要介绍一下 &lt;strong&gt;嵌入层 (Embedding Layer)&lt;/strong&gt; 的工作原理。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;嵌入层是聚类 ID 与深度模型连接的桥梁&lt;/strong&gt;。嵌入层的输入是聚类 ID，输出是该聚类 ID 对应的 embedding。在嵌入层中，聚类 ID 的每个枚举值都对应一个可学习的 embedding。如下图，假设聚类 ID 有 5 个枚举值 &lt;code&gt;[0, 1, 2, 3, 4]&lt;/code&gt;，枚举值对应的索引分别为 &lt;code&gt;idx0&lt;/code&gt;, &lt;code&gt;idx1&lt;/code&gt; &amp;hellip; &lt;code&gt;idx4&lt;/code&gt;。当一个样本进入模型，它会根据聚类 id 号（比如 2 号）去找对应的索引（&lt;code&gt;idx2&lt;/code&gt;），然后将索引下的 N 维 embedding 取回。嵌入层在有些地方也被称为码本 (codebook).&lt;/p&gt;</description>
    </item>
    <item>
      <title>流式聚类算法：DenStream 和 CluStream</title>
      <link>https://luochang212.github.io/posts/stream_clustering/</link>
      <pubDate>Sun, 01 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/stream_clustering/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;直接说结论：全量聚类用 DBSCAN；无监督流式聚类用 DenStream；已知聚类数、按较大时间间隔获取聚类标签且对计算量敏感，用 CluStream.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/stream-clustering&#34; target=&#34;_blank&#34;&gt;stream-clustering&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文涉及的内容包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;提供 DBSCAN、DenStream 和 CluStream 三种聚类算法的使用示例&lt;/li&gt;&#xA;&lt;li&gt;开发对 DBSCAN 自动调参并输出聚类标签的函数 &lt;a href=&#34;https://github.com/luochang212/stream-clustering/blob/main/utils.py#L76&#34; target=&#34;_blank&#34;&gt;auto_dbscan&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;验证 DenStream 的推理结果（簇号）是否在学习过程中发生变化：会变&lt;/li&gt;&#xA;&lt;li&gt;DBSCAN、DenStream 和 CluStream 全量训练效果对比：DBSCAN 最好&lt;/li&gt;&#xA;&lt;li&gt;DenStream 和 CluStream 增量训练效果对比：DenStream 最好&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✨ 注意：运行以下代码依赖 &lt;a href=&#34;https://github.com/luochang212/stream-clustering/blob/main/utils.py&#34; target=&#34;_blank&#34;&gt;utils.py&lt;/a&gt; 文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一dbscan&#34;&gt;一、DBSCAN&lt;/h3&gt;&#xA;&lt;p&gt;DBSCAN 是一种基于密度的聚类算法，用于从大量数据中识别出高密度区域并将其分为不同的簇。与传统的基于划分的聚类算法（如 K-means）不同，DBSCAN 不需要预先指定簇的数量，并且能够识别噪声数据和异常值。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;DBSCAN 算法介绍&lt;/li&gt;&#xA;&lt;li&gt;DBSCAN 的简单示例&lt;/li&gt;&#xA;&lt;li&gt;DBSCAN 的可选参数&lt;/li&gt;&#xA;&lt;li&gt;DBSCAN 自动调参：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;基于 K 距离图选择 &lt;code&gt;eps&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;选择 &lt;code&gt;min_samples&lt;/code&gt; 的经验法则&lt;/li&gt;&#xA;&lt;li&gt;使用网格搜索结合合适的评估指标&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;best_params&lt;/code&gt; 进行聚类&lt;/li&gt;&#xA;&lt;li&gt;一站式 DBSCAN 函数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/stream-clustering/blob/main/1.DBSCAN.ipynb&#39;)&#34;&gt;查看笔记&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;二denstream&#34;&gt;二、DenStream&lt;/h3&gt;&#xA;&lt;p&gt;DenStream 适合不知道具体的聚类数，且需要实时获取聚类标签的情况。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;DenStream 算法介绍&lt;/li&gt;&#xA;&lt;li&gt;DenStream 的简单示例&lt;/li&gt;&#xA;&lt;li&gt;DenStream 的可选参数&lt;/li&gt;&#xA;&lt;li&gt;验证：推理结果是否随时间变化&lt;/li&gt;&#xA;&lt;li&gt;DBSCAN 与 DenStream 效果对比&lt;/li&gt;&#xA;&lt;li&gt;使用 DBSCAN 优化过的 &lt;code&gt;epsilon&lt;/code&gt; 参数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/stream-clustering/blob/main/2.DenStream.ipynb&#39;)&#34;&gt;查看笔记&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;三clustream&#34;&gt;三、CluStream&lt;/h3&gt;&#xA;&lt;p&gt;CluStream 是一种需要明确指定聚类数的算法。它在一段时间内的聚类效果不错，也就是说，如果你的需求是有时间间隔的，比如每 10 分钟获取一次聚类结果，CluStream 的效果是可以接受的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>频繁模式挖掘</title>
      <link>https://luochang212.github.io/posts/frequent_pattern_mining/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/frequent_pattern_mining/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;挖掘 &lt;strong&gt;频繁项集&lt;/strong&gt; 和 &lt;strong&gt;频繁序列&lt;/strong&gt; 是频繁模式挖掘的两个经典任务。它俩的区别是：前者是顺序无关的，而后者关注顺序。对于这两种任务，Spark 已经有非常成熟的解决方案了，在当前主流公司的数据量级下是够用的。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/frequent-pattern-mining&#34; target=&#34;_blank&#34;&gt;frequent-pattern-mining&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;频繁项集&lt;/strong&gt; 经常被念叨的一个用途，是挖掘经常被一起购买的商品（比如奶粉和尿布）。如果知道哪些商品经常被一起购买，就可以将这些商品打包出售。或者放在超市里相隔较远的两个地方，引导用户多逛。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;频繁序列&lt;/strong&gt; 也很有用。用户的连续行为可以看作一个序列。通过分析用户的频繁序列，产品经理可以发现用户习惯，进而优化功能排布和页面顺序，达到提升链路转化效率的效果。&lt;/p&gt;&#xA;&lt;p&gt;✨ 注意：运行以下代码依赖 &lt;a href=&#34;https://github.com/luochang212/frequent-pattern-mining/blob/main/utils.py&#34; target=&#34;_blank&#34;&gt;utils.py&lt;/a&gt; 文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一频繁项集算法fpgrowth&#34;&gt;一、频繁项集算法：FPGrowth&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据预处理&lt;/li&gt;&#xA;&lt;li&gt;频繁项挖掘&#xA;&lt;ul&gt;&#xA;&lt;li&gt;频繁项集&lt;/li&gt;&#xA;&lt;li&gt;关联规则&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/frequent-pattern-mining/blob/main/1.FP-Growth.ipynb&#39;)&#34;&gt;查看示例&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;二频繁序列算法prefixspan&#34;&gt;二、频繁序列算法：PrefixSpan&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个简单的例子&lt;/li&gt;&#xA;&lt;li&gt;子序列挖掘&#xA;&lt;ul&gt;&#xA;&lt;li&gt;商品编码&lt;/li&gt;&#xA;&lt;li&gt;生成商品序列&lt;/li&gt;&#xA;&lt;li&gt;计算频繁子序列&lt;/li&gt;&#xA;&lt;li&gt;通过子序列回溯原始数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/frequent-pattern-mining/blob/main/2.PrefixSpan.ipynb&#39;)&#34;&gt;查看示例&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;p&gt;参考：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://spark.apache.org/docs/latest/ml-frequent-pattern-mining.html&#34; target=&#34;_blank&#34;&gt;Frequent Pattern Mining&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.kaggle.com/code/prasad22/market-basket-analysis-with-apriori-algorithm&#34; target=&#34;_blank&#34;&gt;Market Basket Analysis with Apriori Algorithm&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div id=&#34;mini-overlay&#34; onclick=&#34;overlay_off()&#34;&gt;&lt;/div&gt;&#xA;&lt;div id=&#34;mini-window&#34;&gt;&lt;iframe id=&#34;mini-iframe&#34; frameBorder=&#34;0&#34;&gt;&lt;/iframe&gt;&lt;/div&gt;&#xA;&lt;button id=&#34;btn-close&#34; onclick=&#34;overlay_off()&#34;&gt;×&lt;/button&gt;&#xA;&lt;script src=&#34;https://luochang212.github.io/python-tips/overlay.js&#34;&gt;&lt;/script&gt;&#xA;&lt;link rel=&#34;stylesheet&#34; href=&#34;https://luochang212.github.io/python-tips/style.css&#34;&gt;</description>
    </item>
    <item>
      <title>SynchroTrap 算法实现</title>
      <link>https://luochang212.github.io/posts/synchrotrap/</link>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/synchrotrap/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;SynchroTrap 是基于 Jaccard 相似度和最大连通子图的异常检测算法，出自 Facebook 的论文 &lt;a href=&#34;https://users.cs.duke.edu/~xwy/publications/SynchroTrap-ccs14.pdf&#34; target=&#34;_blank&#34;&gt;Uncovering Large Groups of Active Malicious Accounts in Online Social Networks&lt;/a&gt;.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/SynchroTrap&#34; target=&#34;_blank&#34;&gt;SynchroTrap&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文做了什么：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用 &lt;code&gt;mimesis&lt;/code&gt; 生成源数据，并基于源数据构造正态分布的样本&lt;/li&gt;&#xA;&lt;li&gt;通过构造一个 $\lambda$ 可调的泊松过程，生成用户到访时间戳&lt;/li&gt;&#xA;&lt;li&gt;提供一个由 7 个变量控制的异常数据生成函数，见 &lt;a href=&#34;https://github.com/luochang212/SynchroTrap/blob/main/utils.py#L236&#34; target=&#34;_blank&#34;&gt;gen_attack_df&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;用 Jaccard 相似度构图，再用 &lt;code&gt;NetworkX&lt;/code&gt; 对图做可视化&lt;/li&gt;&#xA;&lt;li&gt;用 Spark 的 &lt;code&gt;graphframes&lt;/code&gt; 计算最大连通子图&lt;/li&gt;&#xA;&lt;li&gt;复现了论文 2.2 节的可视化效果，见 &lt;a href=&#34;https://luochang212.github.io/posts/synchrotrap/#%E4%B8%89%E8%AF%84%E4%BC%B0%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96&#34;&gt;评估与可视化&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;介绍如何使用 &lt;code&gt;Docker&lt;/code&gt; 构建 Spark 开发环境&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;✨ 注意：运行以下代码依赖 &lt;a href=&#34;https://github.com/luochang212/SynchroTrap/blob/main/utils.py&#34; target=&#34;_blank&#34;&gt;utils.py&lt;/a&gt; 文件和 &lt;a href=&#34;https://github.com/luochang212/SynchroTrap/tree/main/gen_data&#34; target=&#34;_blank&#34;&gt;gen_data&lt;/a&gt; 库。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一样本生成&#34;&gt;一、样本生成&lt;/h3&gt;&#xA;&lt;p&gt;脱离互联网企业，我们很难拿到可供挖掘的异常数据样本。一种方法是自己生成。自己生成样本的好处是能拿到真正的 ground truth，而且可以精细地控制异常的规模和程度。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;生成源数据&lt;/li&gt;&#xA;&lt;li&gt;生成大盘数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生成正态样本分布&lt;/li&gt;&#xA;&lt;li&gt;生成 uid 并计算访问次数&lt;/li&gt;&#xA;&lt;li&gt;时间与时间戳&lt;/li&gt;&#xA;&lt;li&gt;用户日志表&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;生成异常数据&#xA;&lt;ul&gt;&#xA;&lt;li&gt;选择攻击开始时间&lt;/li&gt;&#xA;&lt;li&gt;获取 ip 池&lt;/li&gt;&#xA;&lt;li&gt;发起攻击&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;整合两份数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; 与异常捕获的难度有关的变量：&lt;/p&gt;</description>
    </item>
    <item>
      <title>图算法笔记</title>
      <link>https://luochang212.github.io/posts/graph_algorithms/</link>
      <pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/graph_algorithms/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;记笔记能让脑子里的知识结构化说是&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/graph-algorithm&#34; target=&#34;_blank&#34;&gt;graph-algorithm&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;一图的基础操作&#34;&gt;一、图的基础操作&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.创建图&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.1 从空图开始创建&lt;/li&gt;&#xA;&lt;li&gt;1.2 用边文件创建&lt;/li&gt;&#xA;&lt;li&gt;1.3 用已经存在的图、边的列表创建&lt;/li&gt;&#xA;&lt;li&gt;1.4 创建带权边&lt;/li&gt;&#xA;&lt;li&gt;1.5 为图添加属性&lt;/li&gt;&#xA;&lt;li&gt;1.6 创建有向图&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2.可视化&#xA;&lt;ul&gt;&#xA;&lt;li&gt;random&lt;/li&gt;&#xA;&lt;li&gt;circular&lt;/li&gt;&#xA;&lt;li&gt;spectral&lt;/li&gt;&#xA;&lt;li&gt;shell&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;3.中心性度量&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Degree Centrality&lt;/li&gt;&#xA;&lt;li&gt;Closeness Centrality&lt;/li&gt;&#xA;&lt;li&gt;Betweenness Centrality&lt;/li&gt;&#xA;&lt;li&gt;Eigenvector Centrality&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;4.随机图生成&lt;/li&gt;&#xA;&lt;li&gt;5.读写文件&#xA;&lt;ul&gt;&#xA;&lt;li&gt;写入文件&lt;/li&gt;&#xA;&lt;li&gt;读出数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/graph-algorithm/blob/main/1.base.ipynb&#39;)&#34;&gt;查看示例&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;二通用图算法&#34;&gt;二、通用图算法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;连通性 Connectivity&lt;/li&gt;&#xA;&lt;li&gt;最短路 Shortest Paths&lt;/li&gt;&#xA;&lt;li&gt;相似性度量 Similarity Measures&lt;/li&gt;&#xA;&lt;li&gt;距离度量 Distance Measures&lt;/li&gt;&#xA;&lt;li&gt;链接预测 Link Prediction&lt;/li&gt;&#xA;&lt;li&gt;匹配 Matching&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/graph-algorithm/blob/main/2.algorithms.ipynb&#39;)&#34;&gt;查看示例&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;三社区检测算法&#34;&gt;三、社区检测算法&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.常见社区检测算法&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1.1 label Propagation&lt;/li&gt;&#xA;&lt;li&gt;1.2 Girvan-Newman&lt;/li&gt;&#xA;&lt;li&gt;1.3 Greedy Modularity&lt;/li&gt;&#xA;&lt;li&gt;1.4 Louvain&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;2.是否接受边权作为输入&#xA;&lt;ul&gt;&#xA;&lt;li&gt;推荐使用 louvain&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;button class=&#34;demo-btn&#34; onclick=&#34;window_on(&#39;https://nbviewer.org/github/luochang212/graph-algorithm/blob/main/3.community.ipynb&#39;)&#34;&gt;查看示例&lt;/button&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&lt;h3 id=&#34;四图嵌入&#34;&gt;四、图嵌入&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;施工中&lt;/p&gt;</description>
    </item>
    <item>
      <title>算法集萃</title>
      <link>https://luochang212.github.io/posts/algorithms/</link>
      <pubDate>Fri, 03 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/algorithms/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;算法学习笔记，长期更新 &lt;img src=&#34;https://luochang212.github.io/img/quyin/witty.png&#34; class=&#34;my-emoji&#34; style = &#34;height: 32px;&#34;&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/python-tips/tree/master/algorithms&#34; target=&#34;_blank&#34;&gt;python-tips/algorithms&lt;/a&gt;&lt;/p&gt;&#xA;&lt;!-- ### 查找&#xA;&#xA;（1）二分查找&#xA;&#xA;LeetCode 704&#xA;&#xA;给定有序列表 nums，查找目标 target。如果不存在输出 -1；存在则输出下标。&#xA;```python&#xA;class Solution:&#xA;    def search(self, nums, target):&#xA;        if nums:&#xA;            left = mid = 0&#xA;            right = len(nums)&#xA;            while left &lt; right:&#xA;                mid = left + (right - left) // 2&#xA;                if nums[mid] == target:&#xA;                    return mid&#xA;                elif nums[mid] &lt; target:&#xA;                    left = mid + 1&#xA;                elif nums[mid] &gt; target:&#xA;                    right = mid&#xA;        return -1&#xA;```&#xA;&#xA;（2）100 以内质数&#xA;&#xA;统计 100 以内质数的数量。&#xA;&#xA;```python&#xA;class Solution:&#xA;    def prime(self):&#xA;        ans = [2]&#xA;        for i in range(3, 100):&#xA;            flag = True&#xA;            for j in ans:&#xA;                if i % j == 0:&#xA;                    flag = False&#xA;            if flag:&#xA;                ans.append(i)&#xA;        return ans&#xA;```&#xA;&#xA;（3）计数质数&#xA;&#xA;LeetCode 204&#xA;&#xA;统计所有小于非负整数 n 的质数的数量。&#xA;&#xA;```python&#xA;class Solution:&#xA;    def countPrimes(self, n):&#xA;        if n &lt; 3:&#xA;            return 0&#xA;        res = [1] * n&#xA;        res[0], res[1] = 0, 0&#xA;        for i in range(2, int(n**0.5)+1):&#xA;            if res[i] == 1:&#xA;                res[i*i:n:i] = [0]*len(res[i*i:n:i])&#xA;        return sum(res)&#xA;``` &#xA;--&gt;&#xA;&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;&#xA;&lt;p&gt;本节介绍各种排序算法的思路和特点，并提供了示例代码。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
