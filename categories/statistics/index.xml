<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Statistics on Chang Luo</title>
    <link>https://luochang212.github.io/categories/statistics/</link>
    <description>Recent content in Statistics on Chang Luo</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Jul 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luochang212.github.io/categories/statistics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>因果推断笔记</title>
      <link>https://luochang212.github.io/posts/causal_inference/</link>
      <pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/causal_inference/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;不谜语人的因果推断笔记！&lt;/p&gt;&#xA;&lt;p&gt;学习统计最好还是学习一下 &lt;a href=&#34;https://www.r-project.org&#34;&gt;R 语言&lt;/a&gt;。相比 Python，R 是专门用于统计的语言，它提供了更细致的函数和更标准的实现方法。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;1-因果推断入门&#34;&gt;1. 因果推断入门&lt;/h2&gt;&#xA;&lt;p&gt;小朋友感冒，家长给他吃药，一个星期后就痊愈了。那么“吃药”和“痊愈”是否有因果关系呢？&lt;/p&gt;&#xA;&lt;p&gt;我们知道普通的小感冒，即使不吃药，一个星期后也会痊愈。因此未必是因为吃药才痊愈的，也有可能是小朋友凭借抵抗力恢复了健康。此时，要进一步分析“吃药”与“痊愈”的因果关系，就要用到因果推断技术。&lt;/p&gt;&#xA;&lt;p&gt;注意在上述例子中，原因存在两种状态：吃药/不吃药。结果也存在两种状态：痊愈/未痊愈。为了描述方便，我们把：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;作为原因的变量：x 叫做控制变量 (control variable)，或解释变量 (explanatory variable)&lt;/li&gt;&#xA;&lt;li&gt;作为结果的变量：y 叫做响应变量 (response variable)，或被解释变量 (explained variable)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;11-如何测量因果关系&#34;&gt;1.1 如何测量因果关系&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;反事实因果分析框架&lt;/strong&gt; 是统计学中分析因果关系的一种常见思路。这种思路把一种“状态”与其“反事实状态”造成&lt;strong&gt;结果的差异&lt;/strong&gt;当作因果效应。对于小朋友 &lt;code&gt;$i$&lt;/code&gt;，反事实因果分析框架反映的因果效应 &lt;code&gt;$\tau_{i}$&lt;/code&gt; 表示为：&#xA;&lt;code&gt;$$\tau_{i} = Y_{i}(1) - Y_{i}(0)$$&lt;/code&gt;&#xA;这里 &lt;code&gt;$Y_{i}(1)$&lt;/code&gt; 代表吃药，&lt;code&gt;$Y_{i}(0)$&lt;/code&gt; 代表不吃药，它们都是观测值。&lt;/p&gt;&#xA;&lt;p&gt;不难发现，&lt;code&gt;$Y_{i}(1)$&lt;/code&gt; 和 &lt;code&gt;$Y_{i}(0)$&lt;/code&gt; 是无法同时观测到的。这被称为 &lt;strong&gt;因果推断的根本性问题&lt;/strong&gt; (Holland, 1986)。正如“人不能两次踏入同一条河流”，一旦做出某种选择，其他选择的结果就无从观测了。&lt;/p&gt;&#xA;&lt;p&gt;由于此“根本性问题”的存在，对 &lt;code&gt;$\tau$&lt;/code&gt; 算不了真实值，只能估计。因果效应 &lt;code&gt;$\tau$&lt;/code&gt; 有三种常见的&lt;strong&gt;估计值&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我们约定：是否吃药用 &lt;code&gt;$X$&lt;/code&gt; 表示，&lt;code&gt;$X = 0 \space or \space 1$&lt;/code&gt;，其中 1 代表吃药，0 代表不吃药。这里有必要区分下，&lt;code&gt;$Y_{i}|X=1$&lt;/code&gt; 是指那些真的吃了药的人的 &lt;code&gt;$Y$&lt;/code&gt; 值。&lt;code&gt;$Y_{i}(1)$&lt;/code&gt;、&lt;code&gt;$Y_{i}(0)$&lt;/code&gt; 则是看不到的一个潜在状态，可能是用统计方法算出的估计值，也可能是模型的外推。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;1.&lt;strong&gt;ATT&lt;/strong&gt; (average treatment effect on treated)：实验组平均因果效应&#xA;&lt;code&gt;$$\tau_{ATT} = E( \space (Y_{i}|X=1) - Y_{i}(0) \space )$$&lt;/code&gt;&#xA;2.&lt;strong&gt;ATU&lt;/strong&gt; (average treatment effect on untreated)：控制组平均因果处理效应&#xA;&lt;code&gt;$$\tau_{ATU} = E( \space Y_{i}(1) - (Y_{i}|X=0) \space )$$&lt;/code&gt;&#xA;3.&lt;strong&gt;ATE&lt;/strong&gt; (average treatment effect)：平均因果处理效应&#xA;&lt;code&gt;$$\tau_{ATE} = \pi * \tau_{ATT} + (1 - \pi) * \tau_{ATU} $$&lt;/code&gt;&#xA;其中，&lt;code&gt;$\pi$&lt;/code&gt; 是吃药的人（即&lt;code&gt;$X=1$&lt;/code&gt;）在所有样本中所占的比例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>统计学补完计划</title>
      <link>https://luochang212.github.io/posts/learning_statistics/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/learning_statistics/</guid>
      <description>&lt;!-- &gt; 统计并非抽象的学科。虽然派生了推断、估计等抽象概念，但它并非为抽象而抽象，为思辩而思辨。&#xA;&gt; &#xA;&gt; 统计发展抽象概念，通常是为了解决现实中的问题。举个例子，一根头发也没有的人是秃子。那么有十根头发的人呢？有二十根头发的人呢？在一般的认识里，我们认为他们也是秃子。那么究竟要达到多少根毛，才能不被称为秃子呢？统计推断可以利用样本的分布信息，给这个问题一个量化的解答。这就是统计的魅力所在。 --&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;统计学绝非一门生硬无趣的学科，它有着鲜活的案例和丰富的实验，让我们循着公式乘着代码在统计的海洋里尽情摇摆叭 &lt;img src=&#34;https://luochang212.github.io/img/quyin/maimeng.png&#34; class=&#34;my-emoji&#34; style = &#34;height: 32px;&#34;&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;1-回归分析&#34;&gt;1. 回归分析&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-简单线性回归模型&#34;&gt;1.1 简单线性回归模型&lt;/h4&gt;&#xA;&lt;h5 id=&#34;1-回归方程&#34;&gt;(1) 回归方程&lt;/h5&gt;&#xA;&lt;p&gt;许多回归分析都是在如下假设前提下开始的：&lt;code&gt;$y$&lt;/code&gt; 和 &lt;code&gt;$x$&lt;/code&gt; 是两个代表某个总体的变量，我们希望用 &lt;code&gt;$x$&lt;/code&gt; 解释 &lt;code&gt;$y$&lt;/code&gt;，通过一个线性方程，我们可以刻画 &lt;code&gt;$y$&lt;/code&gt; 和 &lt;code&gt;$x$&lt;/code&gt; 之间的关系：&#xA;&lt;code&gt;$$y=\beta_{0}+\beta_{1} x+u \quad (1.1)$$&lt;/code&gt;&#xA;假定方程 (1.1) 在我们所关注的总体中成立，它便定义了一个&lt;strong&gt;简单线性回归模型&lt;/strong&gt; (simple linear regression model).&lt;/p&gt;&#xA;&lt;p&gt;其中，各符号含义如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;$y$&lt;/code&gt;: 因变量（或被解释变量、回归子）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$x$&lt;/code&gt;: 自变量（或解释变量、回归元）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$u$&lt;/code&gt;: 误差项（或干扰项）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$\beta_{1}$&lt;/code&gt;: 斜率参数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$\beta_{0}$&lt;/code&gt;: 截距参数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;举例来说，假设我们用方程 (1.1) 来刻画大豆收成：&lt;code&gt;$y$&lt;/code&gt; 表示收成，&lt;code&gt;$x$&lt;/code&gt; 表示施肥量，&lt;code&gt;$u$&lt;/code&gt; 则包括了诸如土地质量、降水量等因素。&lt;/p&gt;&#xA;&lt;h5 id=&#34;2-零条件均值假设&#34;&gt;(2) 零条件均值假设&lt;/h5&gt;&#xA;&lt;p&gt;只有在我们对 &lt;code&gt;$x$&lt;/code&gt; 和 &lt;code&gt;$u$&lt;/code&gt; 之间的关系做出&lt;strong&gt;某种约束&lt;/strong&gt;时，我们才能计算出 &lt;code&gt;$\beta_{1}$&lt;/code&gt; 和 &lt;code&gt;$\beta_{0}$&lt;/code&gt; 的可靠估计量。&lt;/p&gt;&#xA;&lt;p&gt;🌟 零条件均值假定：&#xA;&lt;code&gt;$$\begin{aligned} &amp;amp;\mathrm{E}(u)=0  \quad (1.2) \\ &amp;amp;\mathrm{E}(u \mid x)=\mathrm{E}(u)  \quad (1.3) \end{aligned}$$&lt;/code&gt;&#xA;方程 (1.2) 和 (1.3) 称作&lt;strong&gt;零条件均值假定&lt;/strong&gt; (zero conditional mean assumption). 有了这两个约束，我们就能计算 &lt;code&gt;$\beta_{1}$&lt;/code&gt; 和 &lt;code&gt;$\beta_{0}$&lt;/code&gt; 了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>泊松分布的仿真及可视化</title>
      <link>https://luochang212.github.io/posts/poisson/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/poisson/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本文介绍泊松分布和泊松函数的定义，并通过 Python random 库对泊松分布进行仿真，带你触摸复杂表象下的简单本质。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/python-tips/blob/master/poisson/poisson.py&#34; target=&#34;_blank&#34;&gt;python-tips/poisson&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-从泊松函数讲起&#34;&gt;1. 从泊松函数讲起&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Poisson_distribution&#34;&gt;泊松分布&lt;/a&gt; 表示在&lt;strong&gt;给定时间段&lt;/strong&gt;内发生&lt;strong&gt;给定数量的事件&lt;/strong&gt;的概率。这个定义比较抽象。举个具体的例子，假设你每小时接到电话的概率是固定的，比如每小时 0.05 个，那么你在接下来 1 小时内接到电话个数的概率，就服从泊松分布:&lt;/p&gt;&#xA;&lt;p&gt;1 小时内接到 0 个电话，对应一个概率值 &lt;code&gt;$P_0$&lt;/code&gt;；&lt;/p&gt;&#xA;&lt;p&gt;1 小时内接到 1 个电话，对应一个概率值 &lt;code&gt;$P_1$&lt;/code&gt;；&lt;/p&gt;&#xA;&lt;p&gt;&amp;hellip; &amp;hellip;&lt;/p&gt;&#xA;&lt;p&gt;1 小时内接到 n 个电话，也对应一个概率值&lt;code&gt;$P_n$&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这些概率值组成一个概率分布列，它们的值  &lt;code&gt;$(n, P_n)$&lt;/code&gt;  在二维坐标下连成一条&lt;strong&gt;曲线&lt;/strong&gt;。这条曲线所在的函数就是&lt;strong&gt;泊松分布的概率密度函数&lt;/strong&gt;。其公式及图像如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;$$\boxed{P(k | t, \lambda)=\frac{(\lambda t)^{k}}{k !} \exp (-\lambda t)}$$&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://luochang212.github.io/img/The-Poisson-distribution.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从公式中，我们可以看出：只要确定了 &lt;code&gt;$\lambda$&lt;/code&gt; 和 &lt;code&gt;$t$&lt;/code&gt;，该式就退化成了概率 &lt;code&gt;$P$&lt;/code&gt; 关于事件发生次数 &lt;code&gt;$k$&lt;/code&gt; 的函数。 类似地，如果我们确定了 &lt;code&gt;$\lambda$&lt;/code&gt; 和 &lt;code&gt;$k$&lt;/code&gt;，则该式退化成概率&lt;code&gt;$P$&lt;/code&gt; 关于时间范围 &lt;code&gt;$t$&lt;/code&gt; 的函数。&lt;/p&gt;&#xA;&lt;p&gt;“确定哪些参数，让函数最终退化成哪些参数的函数”，这个选择和我们的研究目的有关。如果你对不同 &lt;code&gt;$k$&lt;/code&gt; 如何影响 &lt;code&gt;$P$&lt;/code&gt; 值感兴趣，那么就应该确定参数 &lt;code&gt;$\lambda$&lt;/code&gt; 和 &lt;code&gt;$t$&lt;/code&gt;。如果对 &lt;code&gt;$t$&lt;/code&gt; 和 &lt;code&gt;$P$&lt;/code&gt; 之间的关系感兴趣，那么就应该确定参数 &lt;code&gt;$\lambda$&lt;/code&gt; 和 &lt;code&gt;$k$&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>贝叶斯方法</title>
      <link>https://luochang212.github.io/posts/bayesian/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/bayesian/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;统计学中有两大学派，频率学派和贝叶斯学派。频率派用总体信息和样本信息进行统计推断。而贝叶斯派除了使用以上两种信息之外，还使用&lt;strong&gt;先验信息&lt;/strong&gt;进行统计推断。本文从数学原理和编程实践两个方向探究贝叶斯方法。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;本文从数学原理和编程实践两个方面来介绍贝叶斯方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;数学原理&#34;&gt;数学原理&lt;/h2&gt;&#xA;&lt;p&gt;贝叶斯理论包含很多内容。我们熟悉的利用先验分布推后验分布的方法被称为&lt;strong&gt;贝叶斯推理&lt;/strong&gt;（Bayesian inference）。此外，还可以利用参数的后验分布的均值作为该参数的点估计，这种方法被称为&lt;strong&gt;贝叶斯估计&lt;/strong&gt;（Bayesian estimation）。本文数学原理部分主要介绍贝叶斯推理和贝叶斯估计。&lt;/p&gt;&#xA;&lt;p&gt;理论部分为六节，各节的主要内容如下。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;章节&lt;/th&gt;&#xA;          &lt;th&gt;主要内容&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第一节&lt;/td&gt;&#xA;          &lt;td&gt;用一个简单的实例，让大家对贝叶斯方法有一个形象的认识。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第二节&lt;/td&gt;&#xA;          &lt;td&gt;用一个复杂的实例，让大家对贝叶斯方法的术语有一个形象的认识。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第三节&lt;/td&gt;&#xA;          &lt;td&gt;介绍贝叶斯公式的事件形式及其推导。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第四节&lt;/td&gt;&#xA;          &lt;td&gt;介绍贝叶斯公式的密度函数形式及其推导。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第五节&lt;/td&gt;&#xA;          &lt;td&gt;介绍贝叶斯估计。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;第六节&lt;/td&gt;&#xA;          &lt;td&gt;探索联合分布蕴含了哪些信息。&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;一实例癌症化验的准确率&#34;&gt;一、实例：癌症化验的准确率&lt;/h3&gt;&#xA;&lt;p&gt;下面请各位做题家们做一下你们最爱的经典老题 &lt;img src=&#34;https://luochang212.github.io/img/quyin/watermaleon.png&#34; class=&#34;my-emoji&#34; style = &#34;height: 32px;&#34;&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;-题目&#34;&gt;📖 题目&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;有两个可选的假设&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;病人有癌症（cancer）、病人无癌症（normal）&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;可用数据来自化验结果&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;正（+）、负（-）&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;有先验知识&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;在所有人口中，患病率是 0.8%。对确实有病的患者的化验准确率为 98%，对确实无病的患者的化验准确率为 97%，总结如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;$ P(cancer) = 0.008, P(normal) = 0.992 \\ P(+ | cancer) = 0.98, P(- | cancer) = 0.02 \\ P(+ | normal) = 0.03, P(- | normal) = 0.97 $&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
