<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Chang Luo</title>
    <link>http://luochang212.github.io/posts/</link>
    <description>Recent content in Posts on Chang Luo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://luochang212.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Python Tips</title>
      <link>http://luochang212.github.io/posts/python-tips/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/python-tips/</guid>
      <description>Python 技巧合集，长期更新  GitHub项目地址：python-tips
本文记录了一些代码模版。实现相似功能的时候，改改参数就能用，非常方便。
画图篇 Matplotlib 和 Seaborn 是 Python 环境下比较常用的两个画图库。本例展示了用 Matplotlib 绘制条形图、饼图、折线图和用 Seaborn 绘制复杂折线图的方法。
这里需要专门提一下 Seaborn 的一个坑。
在 Seaborn 的 lineplot() 方法中，如果没有将参数 sort 设为 False，则图像横轴标签将按 String 的默认方法排序。这会造成什么困扰呢？举个例子，如果你的图像横轴标签是 1 到 12 月份，那么在未设置 sort 为 False 的情况下，图像横轴标签的实际显示顺序是：1月，10月，11月，12月，2月，3月，&amp;hellip; 8月，9月。你会发现，原本应该排在末尾的 10、11、12 三个月份，根据默认的排序方法，自动跑到 2 月前面去了。横轴标签是数字或英文还好，如果是中文，那么排序方法就更迷了，分分钟破坏数据之间的逻辑关联。
下图展示了未设置 sort 参数的情况下，中文横轴标签的迷之排序。
 PS：点击下方按钮可在 nbviewer 中查看示例。如果需要下载和收藏，请点文章开头的GitHub项目地址链接。
  查看示例 
字典篇 鉴于 JSON 在大数据中的大量使用，字典的重要性也不言而喻。
本文从以下几个方面介绍字典：
 创建 获取 更新 遍历 排序 删除 字典与JSON   查看示例</description>
    </item>
    
    <item>
      <title>Elasticsearch 初探</title>
      <link>http://luochang212.github.io/posts/elastic-search/</link>
      <pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/elastic-search/</guid>
      <description>Elasticsearch 是一个开源分布式全文搜索引擎。它建立在当前最先进有效的搜索引擎库 Lucene 之上。Elasticsearch 集成了 Lucene 的检索功能，并通过一套简单的 API 隐藏了 Lucene 的复杂性，使之简单易用。
 初识 ES 的初步介绍
本节将介绍 ES 的几个特性。这些介绍能帮助我们理解 ES 是应什么需求诞生的？它解决了什么问题？它为何如此架构？以及这种架构方式为它带来哪些性能上的提升？这些信息虽然不能直接提升我们使用 ES 的能力，但能从更深的维度帮助我们使用好它。
不仅仅是搜索 ES 不仅能够搜索，它还提供一套分布式实时存储文档的解决方案。 ES 允许用户将数据存储在多个服务器节点上。这些节点能实时共享数据。一旦主节点的内容发生改变，这些改变会实时传递到副节点上，以保证主副节点的内容一致。如果主节点掉线，ES 能立即选举出一个副节点充当主节点。选举过程就像切换开关一样，能够在瞬间完成，从而保证了 ES 的可靠性。
分布式的存储方案不仅仅是基于数据安全的考量，同时也是为了加快检索的速度。利用 MapReduce，ES 可以在多个节点上并行地检索数据，大大缩短了海量数据处理的时间。
领域专用语言 为了统一查询语法，ES 设计了一套领域专用语言 (DSL, domain specific language)。这套语言基于 JSON，优点是简单易学，缺点是在表达复杂的查询时，会显得格外冗长，阅读起来也不太友好。
SQL 和 NoSQL SQL 全称 Structured Query Language。SQL 中的 Structured 突出了它是结构化的查询语言。结构化即受字段限制。SQL 数据库中的每条数据都具有相同的长度，因此可以被视作一张数据表。相比于 SQL，NoSQL 能表达更复杂的内部数据结构。字段之间不相互影响，可以拥有各自的层级结构。因此 NoSQL 数据库要比 SQL 数据库更加灵活且易于拓展。NoSQL 数据库中的数据通常用 JSON 表示。
入门 一些简单概念
文档 在 ES 中，文档是一个特定的术语。它表示用来存储对象的存储单元。一个对象通常不会是简单的键值对，它可能包含更复杂的数据结构，比如日期、地理数据、数组等。为表达这种复杂的、多层次的数据，ES 将 JSON 作为文档存储的固定格式。也就是说在 ES 里，一个文档被存成一个 JSON 值。</description>
    </item>
    
    <item>
      <title>Monaco Editor 入门指南</title>
      <link>http://luochang212.github.io/posts/monaco_editor_tutorial/</link>
      <pubDate>Mon, 07 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/monaco_editor_tutorial/</guid>
      <description>Monaco Editor 是一款开源的在线代码编辑器。它是 VSCode 的浏览器版本，随着近年 VSCode 大热，Monaco Editor 也随之走红。目前虽未登上 Online Editor 领域的宝座，却也隐然有超越几位老前辈（指 CodeMirror, Ace 之流）之势。
  var i = 0; function show_name(id) { i += 1; if (i%2 == 0) { document.getElementById(id).style.display = &#34;none&#34;; } else { document.getElementById(id).style.display = &#34;inline&#34;; } }  GitHub项目链接：monaco-editor-demos
在学习 Monaco Editor 的过程中，我发现网络上的中文教程很少。为了填补这部分空白，我决定写一份入门教程，帮助初学者快速熟悉 Monaco Editor。通过阅读本文，你可以了解以下内容：
 如何安装 如何搭建 如何调用常用 API 如何寻找学习资源  安装 新建项目文件夹，打开它：
$ mkdir my-application $ cd my-application  确保你已经下载了 npm，然后安装 Monaco Editor：$ npm install monaco-editor  搭建  本文提供了搭建 Monaco Editor 的一种方法，此方法的特点是能够兼容文件系统。如果你希望为后续应用添加文件管理系统，那么参考本文的搭建流程可以避免不必要的踩坑。添加文件系统的具体方法参见 monaco-speech-editor。</description>
    </item>
    
    <item>
      <title>Monaco Speech Editor</title>
      <link>http://luochang212.github.io/posts/monaco_speech_editor/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/monaco_speech_editor/</guid>
      <description>Monaco Speech Editor 是一款适用于视障人群的在线代码编辑器。它提供丰富的语音辅助功能，可以精准地定位并朗读用户指定内容。并且，它还提供多种语音模式，比如字符模式、音乐模式、全局模式。这些模式可以根据用户在不同编程阶段的不同需求，提供差异化的语音内容输出。此外，它内置供全盲者使用的操作界面，从而使全盲者无需使用电脑屏幕和鼠标，也能正常使用本编辑器。
 GitHub项目地址：monaco-speech-editor
项目背景 根据世界卫生组织2010年的数据，全盲者在全年龄段人口中所占比例为0.58%。在全盲人口中，大部分是中老年人口。从下图可以看出，致盲风险随着年龄快速升高。在0～14岁人群中，全盲比例仅有0.07%；在15～49岁人群中，全盲比例稍高一些，为0.16%；而在50岁以上人群中，全盲比例则达到了2.39%。
全盲人口的比例不大，但从绝对数值来看却是非常可观的。2010年，世界全盲人口比例为0.58%，但全盲人口数却达到了3936.5万。即使14岁以下人口的全盲比例仅有0.07%，但考虑绝对数值，也达到了142.1万人。
而且并非只有全盲者才需要语音辅助。有相当比例的视力障碍者，即使使用眼镜，也无法矫正到正常视力。这部分的视障者，也是需要语音辅助的。相比于全盲者，视力障碍者的人口则更为庞大，达到了惊人的2亿8538万。
在提倡公平的原则下，我们希望视障者和视力正常的人一样，也能自由地选择职业。事实上现在已经有部分视障工程师，出现在程序员岗位上，证明着他们的实力。本项目旨在为视障程序员编程无障碍化做一些贡献，项目源代码现已在GitHub上以MIT许可证开源。
技术选择 本编辑器是用JavaScript编写的网络应用 (web application)。它只有两项功能需要外部依赖，一个是在线代码编辑器模块，一个是文字转语音模块。
（一）在线代码编辑器
开源的在线代码编辑器还是挺多的，比如：
 Ace CodeMirror Monaco Editor  它们对语法高亮、缩进、代码补全等基础功能都有比较好的支持，用起来大同小异。选择Monaco Editor是因为用惯了VSCode。毕竟Monaco Editor的源代码就是直接从VSCode贴过去的，两者的界面风格和操作方式都极其相似，对VSCode用户比较友好。但后来使用过程中发现打脸了，当然这是后话。
（二）文字转语音
文字转语音 (text to speech) 的应用就更多了，几乎各大公司都推出了自己的应用：
 Amazon Polly Cloud Text-to-Speech Microsoft text to speech API  但鉴于这些应用都需要网络连接，才能获取语音。考虑到网络延迟和脱机使用的问题，本项目并未采用以上任何一种API，而是选择了Web Speech API。Web Speech API本身并不提供语音服务，它事实上起到资源连接的作用。它首先会搜索操作系统，然后将操作系统提供的语音支持集合成一个列表，提供给浏览器使用。所以Web Speech API提供的语音支持会随用户系统的语音支持项而发生变化。因此不排除一些较老的机型无法使用的可能。但本项目认为本地化语音支持比之于对老机型的支持更加重要，因此选择了Web Speech API。这也是一个取向问题。
综上，本项目主要依赖项只有两个：Monaco Editor 和 Web Speech API。事实上，本项目的名称 Monaco Speech Editor，也正是取自这两个依赖项。
需求分析 一名视障程序员或一位全盲者，在使用代码编辑器时，主要有以下信息需求：
 界面内容信息：这个按钮的名称是什么？这项设置的名称是什么？ 界面定位信息：编译器在哪？设置在哪？某项功能的按钮在哪？ 界面反馈信息：我刚刚按下的按钮打开了什么功能？ 编辑器内容信息：这行代码的内容是什么？光标前的字符是什么？ 编辑器定位信息：某个的变量在哪儿？我应该如何跳转到那儿？ 编辑器反馈信息：我刚刚输入了什么字符？我将要删除什么字符？ 光标位置信息：全文一共有多少行代码？我的光标现在停在第几行？ 控制台内容信息：控制台的输出是什么？  功能设计 本项目提供的功能大致可划分为三个类：编辑器的基础功能，语音支持和UI交互辅助。</description>
    </item>
    
    <item>
      <title>Golang学习笔记</title>
      <link>http://luochang212.github.io/posts/learn_golang/</link>
      <pubDate>Fri, 12 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/learn_golang/</guid>
      <description>Golang是2009年由谷歌的三位大佬(Robert Griesemer, Rob Pike, Ken Thompson)创造的一门新语言。Goalng有很多优点。比如，作为静态类型语言，Golang的依赖少，易于部署。它还支持协程并发，支持垃圾回收，可跨平台编译。Golang兼具动态语言的强大表达能力和C的执行效率，被誉为21世纪的C语言。
  var i = 0; function show_name() { i += 1; if (i%2 == 0) { document.getElementById(&#34;names&#34;).style.display = &#34;none&#34;; } else { document.getElementById(&#34;names&#34;).style.display = &#34;inline&#34;; } }  最近在学习Golang，为了寻找配置教程、优秀的电子书以及难度曲线适中的入门实践项目，我颇费了些功夫。趁着记忆还新鲜，我想分享一下我的学习路径以及学习资料。本文涉及Golang的安装、配置、运行以及实践项目。希望通过阅读本文，初学者们可以更快地找到适合自己的学习方向。
下载安装 官网提供标准安装包，一路点击就能完成安装。
安装包的链接是https://golang.org/dl/，更多关于安装的信息见安装 Go.
环境配置 （一）在终端运行
在命令行运行程序几乎不需要配置。只要下载Golang，然后按官方建议，创建一个名为gocode的文件夹，直接在里面写代码就可以了。为了防止以后import其他包发生错误，建议把gocode文件夹放在GOPATH下。如何知道Golang的工作路径(GOPATH)在哪里呢？打开命令行，输入go env，就能在输出里找到工作路径了（注意区别安装路径和工作路径，它们是两个不同的路径）。
下面是Golang在命令行运行时的一些常用命令：
 Linux系统下的常用命令（点击展开） 新建目录
$ mkdir foldername  
打开目录
$ cd foldername  
返回上一级目录
$ cd ..  
新建go文件
$ touch filename.</description>
    </item>
    
    <item>
      <title>排队论在网络性能分析中的应用</title>
      <link>http://luochang212.github.io/posts/network_performance_analysis/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/network_performance_analysis/</guid>
      <description>排队论(queueing theory)也称随机服务系统理论，它研究的内容有三部分：性态问题、最优化问题和统计推断问题。（《运筹学》清华大学出版社）
下图描述了排队过程的一般流程：
现实中的排队问题是多种多样的，对上述“顾客源”和“服务机构”应该作宽泛的理解。顾客和服务机构可以是生物，也可以是非生物；排队结构可以是有形的，也可以是无形的，比如向交换台要求通话的请求；顾客可以走向服务机构，也可以相反，比如送货上门。
 在网络中，服务器和用户之间相互传送数据包。数据包的传送需要时间，因此或多或少都会产生延迟。为了分析这些延迟，我们引入了一系列假设，并利用排队论对网络延迟进行建模分析。
本文将着重介绍网络性能分析(Network performance analysis)中几种常见的排队模型。它们是：
 The M/M/1 queuing system The birth-death process The M/M/m queuing system The M/M/1/m queuing system The M/M/∞ queuing system The M/M/m/m queuing system  另外，作为以上模型的理论基础，本文将首先介绍柏松过程(Poisson process)。
柏松过程的推导 柏松过程是马尔可夫过程的一个特例，在排队论中经常被用来估计顾客到达的概率分布。
（一）柏松过程的假设
 在时间间隔$\Delta t$内，有且仅有一位顾客到达的概率$P$和$\Delta t$成比例，比例系数为$\lambda$
 在时间间隔$\Delta t$内，至多只允许一位顾客到达（否则应该选取一个更短的时间间隔） $$\begin{aligned} P(\text { 在时间间隔 }[t, t+\Delta t] \text { 内，有且仅有一位顾客到达 }) &amp;amp;=\lambda \Delta t \\ P(\text { 在时间间隔 }[t, t+\Delta t]\text { 内，没有顾客到达 }) &amp;amp;=1-\lambda \Delta t \\ P(\text { 在时间间隔 }[t, t+\Delta t]\text { 内，多于一位顾客到达 }) &amp;amp;=0 \end{aligned}$$</description>
    </item>
    
    <item>
      <title>厨房笔记（二）：快手菜合集</title>
      <link>http://luochang212.github.io/posts/kitchen_time_2/</link>
      <pubDate>Tue, 02 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/kitchen_time_2/</guid>
      <description>做饭累不累？如果你只是偶尔做一顿饭以娱身心，还是挺快乐的。但要是餐餐下厨，就没那么好玩了。一日三餐，少说也要花费两三个小时的光景，不但耗损精力，还挤占学习时间。日复一日地做下来，不累才怪。因此，长期做饭的留学生往往会体现三种趋势：做饭价格向便宜收敛，做饭速度向手快收敛，做饭味道向好吃收敛。因为咱追求的就是便宜美味的同时，又省时省力不麻烦。那么下面就由我来给大家盘点一下那些好吃又方便的快手菜吧 
牛肉丸子汤 原料：牛肉丸、醋、香油、白胡椒粉、辣椒粉、葱
做法：
 锅内放牛肉丸，加水至没过牛肉丸，火开到最大。
 等水煮开的同时，把葱切成葱花备用。
 待水煮开，调成中火，保持水面沸腾。然后开始调味，按个人口味加醋和辣椒粉。加白胡椒半勺，香油数滴。
 牛肉丸还是比较易熟的，水开后再煮五至七分钟，加葱花，稍微再煮一分钟，即可起锅。
  
炸三文鱼 原料：三文鱼片、面粉、盐
做法：
 TESCO买的厚三文鱼片，均匀地敷上面粉，直至表面摸不到水分。
 锅里倒少量油铺匀锅底，开中火将油烧热。
 注意三文鱼易焦，只能开小火煎。翻面也不能太勤，否则鱼容易碎。大概三分钟左右翻一次面，反复翻面直至两面煎至金黄。
 煎十分种左右起锅。注意火候，煎得太短里面不熟，煎得太久肉会变柴。
  
烤羊排 原料：羊排、酱油、孜然、黑胡椒、盐、芝麻
做法：
 羊排切段，加黑胡椒，加酱油，加孜然，加盐腌二十分钟。
 放入烤箱，开170度，烤四十分钟。
 出烤箱后撒点芝麻点缀。
  
淡菜排骨汤 原料：排骨、淡菜、豆腐、生姜、蒜
做法：
 烧一锅水，同时把豆腐切块，淡菜洗干净备用。
 下排骨，煮出浮沫后，将排骨捞出，用冷水把排骨冲洗干净。
 再烧一锅水，下淡菜、排骨、豆腐、两瓣蒜、几片生姜，盖上锅盖煮十分钟。
 淡菜有自身的鲜味，不用调味，起锅即食。
  
炒鸡蛋 原料：鸡蛋、葱、洋葱、猪油
做法：
 葱和洋葱切段备用。蛋打成蛋液，加盐备用。
 把葱白和洋葱下锅炒香，剩余葱段放入蛋液中拌匀，待锅内葱香味溢出，下鸡蛋液。
 鸡蛋液微微凝固时，立刻用筷子从四周向中间拨动，使蛋液凝固过程中均匀受热。注意拨动的节奏，不需要拨得太勤或者太缓。
 当鸡蛋熟了以后，应该还是一整块的，而且比较滑嫩。此时，把筷子插入鸡蛋块中，画圆圈将鸡蛋块打散。
 把打散的鸡蛋再翻炒几下，当鸡蛋表面微焦、香味溢出时即可出锅。</description>
    </item>
    
    <item>
      <title>生态系统建模</title>
      <link>http://luochang212.github.io/posts/nature_system/</link>
      <pubDate>Wed, 12 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/nature_system/</guid>
      <description>本文介绍如何用 Agent-based model 的方法，对一个包含狼、麋鹿、草三种生物的生态系统建模。
 GitHub项目地址：nature-system
Agent指个体，Agent-base model即基于个体的模型。在Agent-based model中，虚拟实体(virtual entity)和现实个体一一对应。一般来说，虚拟实体的属性是对现实个体的抽象，虚拟实体的行为则是依照已经写好的规则迭代。这种建模方式往往涉及个体详细的行为模式，因此适合以研究个体行为规则为目的的建模。
需要注意的是，利用Agent-based model方法建模，并不是变量越多越好，过多的变量会造成调试上的困难。选取的变量足够支撑起我们研究的问题就可以了。
 Note: 除了Agent-base model之外，Equation-based model也是一种比较常见的建模方式。Agent-based model适合表达每个个体身上发生了什么，比如个体的速度、位置的变化等。Equation-based model则而更适合表达系统平均发生了什么，比如人口模型中人口数量变化就更适合用Equation-based model建模。
 模型假设 （一）生物的属性
模型内有三种生物：狼(wolf)、麋鹿(moose)、草(grass)。此外，狼还分为头狼和普通狼。下面这张表展示了头狼、普通狼、麋鹿的属性：
   # age food pos speed last_breed population packNo range eaten     头狼 &amp;radic; &amp;radic; &amp;radic; &amp;radic; &amp;radic; &amp;radic;  &amp;radic; &amp;radic;   普通狼 &amp;radic; &amp;radic; &amp;radic; &amp;radic;   &amp;radic;     麋鹿 &amp;radic; &amp;radic; &amp;radic; &amp;radic; &amp;radic;        从上表可以看出，年龄、食物、位置、速度是头狼、普通狼和麋鹿的共有属性。last_breed指和上一次生育的时间间隔，在模型内用一次迭代表示一次时间间隔，因为迭代必须是整数，因此last_breed也是整型变量。头狼特有population属性，用来表示该头狼所在狼群中狼的数量；头狼特有range属性，表示该狼群活动的范围；头狼特有eaten属性，表示狼群在一次迭代中，全体成员吃到的麋鹿的总数。普通狼特有packNo属性，用来标记其所属狼群的头狼在列表中的索引号。普通狼没有last_breed属性，是因为其生育是以整个狼群为单位的。由于狼群是由头狼定义的，狼群相关的属性和行为也绑定在头狼身上，因此在代码实现上，狼群的生育是通过头狼实现的。</description>
    </item>
    
    <item>
      <title>JavaScript初探</title>
      <link>http://luochang212.github.io/posts/to_do_list/</link>
      <pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/to_do_list/</guid>
      <description>初次学习JavaScript，用JS写了一个计划表生成工具。
 项目链接：计划表生成工具
JavaScript是一个神奇的语言。它既不像Java原生地支持类和继承，也不如Python声明变量方便，更兼闹出&amp;rdquo;===&amp;ldquo;这样的麻烦。但我依旧深知它的强大，尤其是在可视化这一方面，在接触qtwebengine的时候已经感受过一次了。目前，我学习JS的平台是W3Schools 和廖雪峰的网站。
话说这是我自学JS以来写的第一个程序，求轻虐(￣▽￣)
我的初衷 我的初衷是制作一个习惯统计工具，用来分析我在长期计划上的坚持能力。于是照例我对它做了一个需求分析。
习惯统计工具的需求分析：
 需要用户能够注册。即能够声明我是谁，并且把我和我的数据绑定。 需要将数据存在文件里，而不是存在缓存文件里。 需要按时间戳对生成的数据进行统计。 需要对最终结果制作统计图表。  通过分析，我发现静态网页很难实现第一第二步。能不能实现我不敢下定论，但肯定有技术难度。目前，我只有一个由GitHub page托管的静态网页，因此我选择退而求其次。先学习生成一个单一的表格，来记录当天计划的执行情况。我把这个工具叫做计划表生成工具。
需求分析 计划表生成工具好比是习惯统计工具的一个子系统。习惯统计工具面向的是连续多天，而计划表生成工具只面向单独一天。
计划表生成工具的需求分析：
 一个UI界面（前端） 一个允许用户做输入、选择和修改操作的数据流（后端） 一个最终显示的表格（前端） 判断此工具是否easy to use，找到不好用的因素并改进 （测试）  此时我们的big picture就已经明确。战略定了，下面来定战术。
步骤分析 （一）添加计划
对于前端UI，首先我们需要一个textarea，用来接收每项计划的内容。还需要一个按钮，点下这个按钮时，将文本框内的信息添加到计划列表。为了便于存储，我为计划(item)设计了一个类。
这个类的声明如下：
var Items = { name: &amp;quot;&amp;quot;, isCheck: &amp;quot;false&amp;quot;, isDelete: &amp;quot;false&amp;quot; };  可以看出这个类有三个值。它们分别表示该对象的名称，是否完成，以及是否删除。每次添加计划，用以下代码实例化这个类(items)，生成一个对象(item)：
var item = Object.create(Items);  （二）生成表格
这一步要把复选框(checkbox)和按钮(button)都和每一行的计划绑定。那么如何绑定呢？
要知道，用for loop遍历subArray的过程，就是生成表格内容的过程。所以，checkbox和button也都是在这次遍历中生成的。那么，我们就可以在它们的生成过程中，创建它们的id，并把id和计划对应起来。
具体到代码中，我用了i.toString(10)将循环数转成string类型，然后加到id上。于是，第一项计划对应的checkbox的id就是&amp;rdquo;cb0&amp;rdquo;, 对应的button的id就是&amp;rdquo;btn0&amp;rdquo;, 以此类推。
for (i = 0; i &amp;lt; subArray.length; i++) { var index = i+1; body += &#39;&amp;lt;tr&amp;gt;&#39;; body += &#39;&amp;lt;td&amp;gt;&#39; + index.</description>
    </item>
    
    <item>
      <title>PyQt5侧边栏布局</title>
      <link>http://luochang212.github.io/posts/pyqt5_layout_sidebar/</link>
      <pubDate>Fri, 10 May 2019 21:43:09 +0100</pubDate>
      
      <guid>http://luochang212.github.io/posts/pyqt5_layout_sidebar/</guid>
      <description>GitHub项目地址：pyqt5-demo
主流软件如网易云音乐、腾讯电脑管家，都有侧边栏。侧边栏能有效扩展应用空间，使软件功能的层次更加分明。
但PyQt5并没有一个专门的方法实现侧边栏。要实现侧边栏，主要有两种技术路线。一是从标签部件(QTabWidget)改造而来，二是用网格布局(QGridLayout)画出来。本文采用第一种技术路线，制作一个简单的侧边栏应用。
 Note: 两种技术路线制作的侧边栏有细微的差别。如果采用第二种技术路线(QGridLayout)，侧边栏和内容页之间没有明显的分界。所以需要额外地在侧边栏和内容页之间加一条线，来突出两者属于不同的组件。而第一种技术路线(QTabWidget)不需要，创建的侧边栏和内容页之间的区别明显。
下图是一个用第二种技术路线(QGridLayout)制作的应用，可以看到侧边栏和内容页中间画了一条线，以突出两个组件的分界。
 步骤分析 在开始写代码之前，我们先分析一下制作侧边栏需要几个步骤。
 添加部件 为部件设置布局 将标签部件改造成侧边栏的内容页 为侧边栏按钮编写函数，实现内容页之间的跳转  添加部件并设置布局 此段不详述。关于部件和布局的基础知识，在上一篇中有介绍，详见PyQt5 布局浅析。
下面这段代码添加了部件且设置了布局。
from PyQt5.QtWidgets import * import sys class Window(QMainWindow): def __init__(self): super().__init__() # set the title of main window self.setWindowTitle(&#39;Sidebar layout - www.luochang.ink&#39;) # set the size of window self.Width = 800 self.height = int(0.618 * self.Width) self.resize(self.Width, self.height) # add all widgets self.btn_1 = QPushButton(&#39;1&#39;, self) self.btn_2 = QPushButton(&#39;2&#39;, self) self.</description>
    </item>
    
    <item>
      <title>PyQt5布局浅析</title>
      <link>http://luochang212.github.io/posts/pyqt5_layout/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/pyqt5_layout/</guid>
      <description>PyQt5是Python环境下用来开发UI界面的一个包。它容易上手，对初学者友好，并且拥有丰富的函数库，可以实现大部分桌面应用的开发需求，且支持QSS语言，能够对界面风格做个性化调整。总体来说，PyQt5是一款开发效率极高的UI框架。这篇文章从零开始，教你搭建一个属于自己的桌面应用。
 GitHub项目地址：pyqt5-demo
创建第一个窗口 一般来说，桌面应用都以窗口(window)形式呈现。因此，要搭建桌面应用，首先要创建窗口。
下面这段代码创建了一个空的窗口。
from PyQt5.QtWidgets import * import sys class Window(QMainWindow): def __init__(self): super().__init__() # set the title of main window self.setWindowTitle(&#39;My first window - www.luochang.ink&#39;) # set the size of window self.Width = 500 self.height = int(0.618 * self.Width) self.resize(self.Width, self.height) if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) ex = Window() ex.show() sys.exit(app.exec_())  这段代码仅仅设置了窗口的标题和大小。下一步，我们要往这个空的窗口里添加部件(widget). 为了规范性，我们在Window类里新建一个函数initUI, 然后在initUI里为窗口添加部件。
为窗口添加部件 下面这段代码为窗口添加了一个按钮部件(QPushButton).
from PyQt5.QtWidgets import * import sys class Window(QMainWindow): def __init__(self): super().</description>
    </item>
    
    <item>
      <title>微博数据可视化</title>
      <link>http://luochang212.github.io/posts/my_weibo/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/my_weibo/</guid>
      <description>GitHub项目地址：weibo-analysis
这次的数据用的是本科期间就已经爬好，但因为当时没有足够的处理技巧，这些数据在硬盘里一丢就是两年。如今，本Python初丁趁着还有机会摸鱼，赶紧把数据翻出来，让它们发光发热。
文本获取 因为新浪微博的严防死打，现如今微博的数据越来越不好爬。GitHub上的微博爬虫生存周期通常都很短，使爬取数据的成本大大增加。这里我用的是微博@失眠狸 同学的方法，用鼠标精灵写了个插件，控制快捷键和页面拖动，把内容从浏览器上粘贴到sublime里。
生成csv文件 有了原始数据，接下来我们要把数据归一化，做成方便处理的数据。一个常用的方法就是将数据整理成csv文件。
Step 1. 分析需要保存的字段以及数据的维度，从而设计出数据的存储结构。根据原数据，我划分了五个字段: id, date, time, device, content, 它们分别记录一条微博的文件位置、发布日期、发布时间、发送设备和文本内容。
Step 2. 分割raw data. 先用split函数进行粗略分割，再用find函数精确分割。接着将分割好的内容提取到各字段，并依次存入csv。
经过上述两步，数据的整理工作就做完啦。
可视化微博数据 有了csv文件，做数据可视化是分分钟的事。此时我把工作平台从PyCharm搬到了Jupyter Notebook。这是因为Jupyter Notebook可以制作的各式各样的可视化图表和窗口小工具(widget), 比PyCharm更适合数据处理。至于工具包，这里我选的是pandas和seaborn.
首先是需求分析，我的目标如下:
 绘制日期分布热力图，观察今年使用微博频率的趋势
 绘制设备使用直方图，看看平时最常用什么平台发博
 绘制时间分布直方图，观察一天之中各时段的发博频率
 使用窗口滑块小部件，拖动查看各个时间段都发了什么内容
  这里不描述具体过程，详见GitHub Repository.
分析结果如下:
热力图总体来说颜色逐年加深，说明我正在逐渐成为一个微博控。而且注意到往年年初我是不怎么玩微博的，但随着年纪渐长，1-3月份我玩微博的频率越来越高，这意味着过年可能越来越无聊，没有年味，从而加长了我混迹微博的时间。
是你吗？华为的舔狗~
晚上2点不睡的坏小孩，早上10点起的偷懒者。（此处是一个卑微的笑容）
附录：部分代码 下面这段代码分割了文本。
def classification(self, txt_array, file_index): id = np.array([]) date = np.array([]) time = np.array([]) device = np.array([]) content = np.array([]) count = 0 for ite in range(1, np.</description>
    </item>
    
    <item>
      <title>TSP旅行路线规划</title>
      <link>http://luochang212.github.io/posts/tsp_route/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/tsp_route/</guid>
      <description>GitHub项目地址：tsp-route
对于在欧洲的小伙伴们，复活节假在这一周就正式开始啦。大家都是怎么计划旅行的呢？
我的习惯是在出发前最后一晚，花上半小时，搜索目的地景点 (Point of interest, POI), 然后在Google Maps上为它们点上小星星，以免和它们擦肩而过。我的地图经过一番操作，就成了下面这副模样。
此时此刻，望着这些密集的星星，我不禁自问：如何才能走最少的路，遍历所有景点呢?
搜索了谷歌和百度，都没找到我要路径规划功能。最接近需求的是谷歌地图的&amp;rdquo;Add destination&amp;rdquo;功能。然而这个功能只是依次连接你点选的地点。并不能由一组地点，确定连接它们的一条全局最短路径。
没有现成应用怎么办，我打算自己动手写一个。
下图是Google Add destination功能。
适用模型：TSP 模型 用一句话概括需求就是：我们需要一条从某地方出发，遍历所有地点，最终回到起点的最短路径。
这个需求其实就是运筹学的一个经典问题，旅行商问题(TSP)。旅行商问题的确切描述是这样的：一个商人在各个城市之间旅行，要求遍历所有城市并返回到出发点，要如何规划路线，才能使总路径最短。（打开维基百科了解更多)
解决思路  用googlemaps包获取纬度和经度信息 用OR-Tools包求解TSP问题 最后用gmaps可视化结果  在敲代码的过程中，最难的地方莫过于看文档查API, 搞清楚输入输出和调用结构。不过敲完这一顿之后我还是不禁感慨，GoogleI太为开发者着想了。一旦学会调用API，实现一个简单应用的代码量还是很小的 orz
食用指南 项目地址 &amp;ndash;&amp;gt; 传送门
在运行代码之前，你需要以下配置：
 一个Jupyter Notebook.  你需要安装这些包：googleplaces, googlemaps, gmaps, ortools. 你需要一个Google Maps API key, 从这里获取API.  完成配置等于成功的一半。在Jupyter notebook打开TSPSolver.ipynb，将第二个代码块的所有变量，改成自己的，比如自己的目的地自己的区域和自己的API密码……最后从头到尾运行所有代码块，你就可以得到自己的定制路线辣~
配置代码如下。
# input the places of interest (POI) places = &#39;YHA London Central Hostel&#39;, &#39;Coca-Cola London Eye&#39;, &#39;St. Paul\&#39;s Cathedral&#39;, &#39;Leadenhall Market&#39;, &#39;The National Gallery&#39; \ &#39;Big Ben&#39;, &#39;Buckingham Palace&#39;, &#39;Waterloo Station&#39; # the region Location=&#39;London&#39; # choose a mode Mode = &amp;quot;walking&amp;quot; # &amp;quot;driving&amp;quot;, &amp;quot;walking&amp;quot;, &amp;quot;bicycling&amp;quot;, &amp;quot;transit&amp;quot; # get Google API key from following website: # https://developers.</description>
    </item>
    
    <item>
      <title>Python解置换群问题</title>
      <link>http://luochang212.github.io/posts/python_math_problem/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/python_math_problem/</guid>
      <description>室友问我一个问题，把我难住了。
想不出解法，遂写了个程序暴力求解。
 题目：A permutation is applied to the string SUPERBGOLDHAT. The same permutation is applied to the output from this operation. The second output is OGTHLEPDSUARB. What was the first output? (Note: as an example, the permutation(1 3 4) applied to WOLF gives FOWL. Write your answer in capital letters inside quotation marks, e.g. &amp;ldquo;BEARDPLUGHOST&amp;rdquo;.)
 把它译成中文就是：已知将某个置换作用于字符串SUPERBGOLDHAT两次，生成字符串OGTHLEPDSUARB. 求该置换作用于字符串SUPERBGOLDHAT一次时，生成的结果。
 Note: 作用两次的意思就是，当一个置换规则作用于字符串一次时，会生成一个新字符串。将这个规则作用在这个新字符串上，又会生成一个字符串，这个字符串就是两次作用的结果。
 近世代数基础 如果你不知道什么是置换的话，可以看一下本节。学过近世代数的同学请自觉跳过这部分ꉂ(ˊᗜˋ*)
我们给定一个序列$a ={1, 2, 3, 4, 5, 6} $ 。然后给定一个作用于该序列的置换：</description>
    </item>
    
    <item>
      <title>厨房笔记</title>
      <link>http://luochang212.github.io/posts/kitchen_time_1/</link>
      <pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/kitchen_time_1/</guid>
      <description>刚到英国那会儿，做饭的兴致很高。每天都跟过家家似的，买菜，钻研菜谱，然后做饭，在厨房里待上四五个小时也不觉得累。大概这就是“人生若只如初见”吧。
 
 拌牛肉 原料：牛肉3两，猪油，葱，酱油，地瓜粉1匙半，盐
做法：
 牛肉顺纹路切成宽约一寸的肉条，肉条逆纹路切片，装碗，用自来水清洗，沥干，加入一匙猪油和适量的盐与酱油，用手抓揉片刻后，加入一匙半的地瓜粉，继续抓握揉捏约3分钟即可，葱切好备用；
 五匙猪油下锅，至微热，放入适量葱头和小半葱段，煎至略有香味溢出，起锅备用；
 水烧沸，调至小火，牛肉下锅，先不要搅动，待地瓜粉固结后，可用筷子将牛肉摊开，当水再次沸腾时，用漏勺将肉舀出，趁热放入煎好的猪油中搅拌，菜即成。
  
亲子丼 原料：米饭，鸡肉，洋葱，鸡蛋，酱油，盐，糖，料酒
做法：
 米饭下锅煮，可弃之不顾。
 鸡肉切小块，放酱油、盐、料酒腌一下；洋葱切短条；鸡蛋稍稍打散。
 鸡肉下锅煎至出油，起锅。此时锅不必洗，放半碗水，加酱油、少量料酒和糖。
 待水烧开，放入鸡肉和洋葱。盖锅盖将鸡肉焖熟，然后倒入一半蛋液，盖锅盖小火焖3分钟。
 起锅盖，倒入剩下一半蛋液。菜即成。
  
红烧肉 原料：五花肉，葱，姜，蒜，大料，老抽，生抽，糖，油
做法：
 五花肉切块，葱切段，蒜切末，姜切条。
 倒油，加葱头、姜条、蒜末、大料，小火熬油。油熬出香味后，放五花肉翻炒，闻香即可起锅。
 另起一锅油，倒六七小勺糖，中火将糖煮化。倒入五花肉，翻炒片刻后，加少量水、老抽、生抽。
 时不时搅拌，尝肉汁甜度，不够可加糖。待锅内汤汁收浓稠，起锅享用。
  
牛肉丸意大利面 原料：意面、牛肉丸、葱、蒜、番茄、番茄酱
做法：
 烧一壶开水，倒入电饭锅，加两勺盐，放入螺旋意大利面。面煮不烂，可以弃之不顾。
 切葱头，剁蒜泥，番茄切小块备用。
 烧一锅油，放入丸子，翻面煎至定型。
 起锅后油不倒，加入蒜泥葱头炒香。番茄块倒入锅中炒软，然后加大量番茄酱，继续翻炒，以防番茄酱烧焦。
 捞面放入锅中和酱汁搅和搅和，放入丸子，起锅开吃。
  
葱油鸡 原料：大鸡腿、葱、姜、蒜、料酒
做法：
 鸡肉处理干净后，用盐给它来个大宝剑。盘中先放葱结、姜片、鸡肉，次淋白葡萄酒。
 鸡肉盛于盘内，冷水入锅，小火蒸20分钟。</description>
    </item>
    
    <item>
      <title>基于蚁群算法的证券投资组合优化</title>
      <link>http://luochang212.github.io/posts/markowitz_model/</link>
      <pubDate>Tue, 15 May 2018 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/markowitz_model/</guid>
      <description>在证券交易中，为了降低风险，经常使用一笔资金购买多支股票。那么，如何合理地选择证券组合，并确定每支证券的资金分配系数，以使预期风险最低，预期收益最高，就成了一个经典的经济学问题 &amp;ndash; 证券投资组合优化问题。
 1952年，马科维茨首次提出均值-方差模型(Markowitz Mean-Variance Model)。该模型利用股票的历史交易数据，定义了股票的预期风险与收益，并引入“无差异曲线”和“有效市场边界”的概念，最终导出了最佳投资组合的计算公式。
本文利用蚁群算法，求解马科维茨均值-方差模型。蚁群算法是一个群体智能算法，因其较强的鲁棒性和适用性，被广泛应用于工业界，是一种研究较为成熟的算法。
研究背景 一个证券投资组合，简单来说就是一组证券及其选购系数的组合。选购系数均大于零（不允许做空），且和为1。
余超在《基于蚁群算法的投资组合优化研究》中给出了完整的模型假设。概括如下：
 一只蚂蚁代表了一个投资组合； 在投资组合优化问题中的蚁群算法要采用连续域优化； 相较于传统蚁群问题，该算法中信息素应该在城市而非路径上积累； 可在蚂蚁移动过程中加入随机扰动以增加全局搜索能力。  余超在模型基础上已经做了非常完整的工作，但是没能求出完整的有效市场边界。
于是，卞蓓丽在《蚁群算法在多目标优化的证券投资组合中的应用研究》中指出，多目标优化的证券投资组合问题是没有绝对最优解的，而是有一群无法相互支配的解形成的有效边界。对多目标优化问题而言，最重要的是求出有效边界，而不仅仅是求出一两个更优解，后者用单目标就可以完成。余超的多目标研究没有求出有效边界。”
卞蓓丽提示我们：首先，投资组合问题，本质上是一个多目标优化问题。其次，我们要计算出完整的有效边界曲线，才算达成预期目标。
余超建立了基础模型，而卞蓓丽在余超的基础上进行了改进。本文借鉴他们二人建立的数学模型，利用多元函数连续域蚁群算法，求解马科维茨均值-方差模型。
研究方法 （一）马科维茨投资组合理论简介
投资组合的预期收益($𝒓_𝒑$)：单一证券i的预期收益为$E\left(r_{i}\right) $，式中$r_{i s}$为针对状况s证券i的收益率，$P_{s}$是状态s出现的概率；在计算了所有N个证券的预期收益率后，就可以计算出证券组合的预期收益率$𝒓_𝒑$，式中$x_{i}$表示组合中证券i所占的比例，即加权系数。
 单一证券i的预期收益: $E\left(r_{i}\right)=\sum_{s=1}^{n} r_{i s} * P_{s}$
 证券组合的预期收益: $\overline{r_{p}}=\sum_{i=1}^{N} x_{i} * E\left(r_{i}\right)$
  投资组合的预期风险($𝝈_{𝒑}$)：单一证券i的预期风险为$\sigma_{\mathrm{i}} $，式中$r_{i s}$为针对状况s证券i的收益率，$P_{S}$是状态s出现的概率，$E\left(r_{i}\right) $为证券i的预期收益率 ；在计算了所有N个证券的预期风险后，就可以计算出证券组合的预期风险$\sigma_{\mathrm{p}}$，式中$\operatorname{cov}_{i j}$表示证券i和证券j的协方差，$x_{i}$和$x_{j}$表示组合中证券i和证券j所占的比例，即加权系数。
 单一证券i的预期风险: $\sigma_{\mathrm{i}}=\left(\sum_{s=1}^{n}\left[r_{i s}-E\left(r_{i}\right)\right]^{2} * P_{S}\right)^{\frac{1}{2}}$
 证券组合的预期风险: $\sigma_{\mathrm{p}}=\left(\sum_{i=1}^{N} \sum_{j=1}^{N} \operatorname{cov}_{i j} * x_{i} * x_{j}\right)^{\frac{1}{2}}$
  有效市场边界: 有效市场边界是所有最佳投资组合(Efficient Portfolio)的集合。有效前沿曲线上面的每一点都代表一个最佳投资组合。下图曲线就是有效市场边界，有效市场边界满足以下两个条件：</description>
    </item>
    
    <item>
      <title>观影：少女哪吒</title>
      <link>http://luochang212.github.io/posts/nezha/</link>
      <pubDate>Tue, 11 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/nezha/</guid>
      <description>青春可贵，文学高华，可是越是珍贵就越脆弱越易碎。对于一般人来说，破碎的疼痛也许还能承受得住，可是对内心敏感的人，这几乎是欲死的折磨。
我发现，影片中很多人都沉浸于某种爱好。王晓冰喜欢文学和音乐，晓冰妈喜欢舞蹈，晓冰爸外面的女人喜欢钢琴。但他们的爱好不是为了艺术，他们只是借沉浸艺术来麻痹自己。
我猜，王晓冰对家人大喊“虚伪”的原因，大概就是看不惯家人的这种自我麻痹吧？看不惯这种因为怯懦、无法承受就转向麻痹自我的态度。她不满拿音乐和舞蹈麻痹自己的母亲，不满借口“恋爱自由”为自己脱责的父亲。
每个人都为着生活痛苦、狂燥、疲惫不堪，在生活的折磨下渐渐失去勇气。因为不忍正视生活之残酷，他们选择戴上虚伪的面具，假装做出幸福的样子。但晓冰不，她个性干爽利落，追求三毛式的真诚和坦率。就算现实让她疼痛到龇牙咧嘴，她也要把那撇开的嘴角当作笑容。
影片里李小路就像一个完美的存在，她的出现对晓冰而言是上苍的馈赠。就像徐杰说小路是侠女，小路确有一股特殊的气质。英气里带点活泼，让人倍感亲切。有时紧锁的眉头和尖利的眼神又不时提醒着她已是一个有了主见的少女。是小路，让晓冰的生活里有了短暂的纯粹的欢乐。
造成晓冰痛苦的原因是多方位的，家庭的破碎，平庸又手握权力的老师的刁难，爱情的不如意，学业的不顺遂等等。对于这一切，晓冰都毅然决然、不顾后果、绝不妥协地抗争。永远高昂着头，又不幸身为下贱，这场景让我想起妙玉。
总体上讲，电影的场景感觉很碎，只给人提供一种感觉。影片没有悲壮的结局，因此对应地也缺少回响。因为没有回响，因此又显得生涩。也不知道这生涩是好是坏，虽说失掉了反复品咂的回味，但又给思考和体验留了更多空间。
（看的电影很少，还是第一次看这么文艺的电影，写一点个人的感觉 Σ Σ Σ (|||▽||| )</description>
    </item>
    
  </channel>
</rss>