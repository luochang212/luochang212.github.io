<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Graph on Chang Luo</title>
    <link>https://luochang212.github.io/tags/graph/</link>
    <description>Recent content in Graph on Chang Luo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 27 Jul 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luochang212.github.io/tags/graph/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SynchroTrap 算法实现</title>
      <link>https://luochang212.github.io/posts/synchrotrap/</link>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/synchrotrap/</guid>
      <description>基于 Jaccard 相似度和最大连通子图的流量风控算法。&#xA;GitHub 项目地址：SynchroTrap&#xA;✨ 本文做了什么：&#xA;用 mimesis 生成源数据，并基于源数据构建正态分布的样本 通过构造一个 $\lambda$ 可调的泊松过程，生成用户的到访时间戳 写了一个由 7 个变量控制的异常数据生成函数，见 gen_attack_df 用 NetworkX 对由 Jaccard 相似度构作的图做可视化 用 Spark 的 graphframes 计算强连通图 复现了论文中 2.2 节的可视化效果，见 评估与可视化 介绍如何用 Docker 构建 Spark 环境 注意：运行以下代码依赖 utils.py 文件&#xA;一、样本生成 脱离互联网企业，我们很难拿到可供挖掘的异常数据样本。一种方法是自己生成。自己生成样本的好处是能拿到真正的 ground truth，而且可以精细地控制异常的规模和程度。&#xA;生成源数据 生成大盘数据 生成正态样本分布 生成 uid 并计算访问次数 时间与时间戳 用户日志表 生成异常数据 选择攻击开始时间 获取 ip 池 发起攻击 整合两份数据 Note: 与异常捕获的难度有关的变量：&#xA;攻击持续的时间 attack_duration 正常 ip 的含量 normal_ip_rate 资源池的大小 ip_num 资源池的隔离 uid_repeat_rate 攻击间隔 max_t - min_t 攻击线程数 epoch 查看笔记 二、算法实现 SynchroTrap 通过构建 &amp;lt;U, T, C&amp;gt; 三元组来衡量用户与用户间的距离。U 代表用户，T 代表时间，C 代表限制项。</description>
    </item>
    <item>
      <title>图算法笔记</title>
      <link>https://luochang212.github.io/posts/graph_algorithms/</link>
      <pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/graph_algorithms/</guid>
      <description>记笔记能让脑子里的知识结构化说是&#xA;GitHub 项目地址：graph-algorithm&#xA;一、图的基础操作 1.创建图 1.1 从空图开始创建 1.2 用边文件创建 1.3 用已经存在的图、边的列表创建 1.4 创建带权边 1.5 为图添加属性 1.6 创建有向图 2.可视化 random circular spectral shell 3.中心性度量 Degree Centrality Closeness Centrality Betweenness Centrality Eigenvector Centrality 4.随机图生成 5.读写文件 写入文件 读出数据 查看示例 二、通用图算法 连通性 Connectivity 最短路 Shortest Paths 相似性度量 Similarity Measures 距离度量 Distance Measures 链接预测 Link Prediction 匹配 Matching 查看示例 三、社区检测算法 1.常见社区检测算法 1.1 label Propagation 1.2 Girvan-Newman 1.3 Greedy Modularity 1.4 Louvain 2.是否接受边权作为输入 推荐使用 louvain 查看示例 四、图嵌入 施工中</description>
    </item>
  </channel>
</rss>
