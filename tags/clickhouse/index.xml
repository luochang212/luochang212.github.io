<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ClickHouse on Chang Luo</title>
    <link>https://luochang212.github.io/tags/clickhouse/</link>
    <description>Recent content in ClickHouse on Chang Luo</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 26 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luochang212.github.io/tags/clickhouse/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>耶是 ClickHouse！我们有救了！！</title>
      <link>https://luochang212.github.io/posts/chat_to_clickhouse/</link>
      <pubDate>Sat, 26 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://luochang212.github.io/posts/chat_to_clickhouse/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;本来我懒得装，但是 MySQL 太慢了，遭不住，咱还是把 ClickHouse 装起来吧。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;GitHub 项目地址：&lt;a href=&#34;https://github.com/luochang212/chat-to-clickhouse&#34; target=&#34;_blank&#34;&gt;chat-to-clickhouse&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;https://luochang212.github.io/posts/agent_project/&#34;&gt;《Agent 实战：智能路由、任务拆解和链路工程》&lt;/a&gt;一文中，我实现了一个简单的 ChatBI，它能查询 MySQL 数据库。对于小批量数据量，MySQL 尚可应付，但是当数据量来到千万量级时，一次 MySQL 查询将消耗数秒甚至数十秒，这么长的等待时间是用户难以忍受的。而且 Agent 还有一个技术问题，它的 NL2SQL 尚未做到 one-shot，也就是说，在拿到最终结果前，它也许需要多次试错，这将进一步拉长查询时间。&lt;/p&gt;&#xA;&lt;p&gt;如何无痛解决查询效率低下的问题呢？很简单，只需要换数据库就可以做到。这便引入今天的主角：ClickHouse。&lt;/p&gt;&#xA;&lt;h3 id=&#34;一分析利器&#34;&gt;一、分析利器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/ClickHouse/ClickHouse&#34;&gt;ClickHouse&lt;/a&gt; 是 Yandex 旗下的一款开源的列式存储数据库，专为 &lt;strong&gt;联机分析处理&lt;/strong&gt; (OLAP) 场景设计。在做数据分析时，它比传统数据库快几倍到几十倍。分析场景的核心需求是「聚合计算」，即 &lt;code&gt;GROUP BY&lt;/code&gt; 子句下的 &lt;code&gt;SUM&lt;/code&gt;, &lt;code&gt;AVG&lt;/code&gt;, &lt;code&gt;COUNT&lt;/code&gt; 操作，这些正是 ClickHouse 的强项。&lt;/p&gt;&#xA;&lt;p&gt;为什么它的聚合计算如此之快呢？因为它具有如下特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;列式存储&lt;/strong&gt;：顾名思义，列存的数据是按列存储的。这种存储方式可以减少无效 I/O，因为列存可以只读取查询中涉及的列。而非行存那样，读取整行后再丢掉不需要的列&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;并行计算&lt;/strong&gt;：列存的另一个优势是数据更容易切分。单列数据的连续性和同构性更强，无需考虑与其他列的关联，因此可以更方便地按维度（如时间区间、数值分段）拆分并分配到不同节点。当然，这种设计的代价是使得插入操作变得更加昂贵&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;物化视图&lt;/strong&gt;：物化视图可以把高频分析的结果提前算好存在表里，后续查询直接读结果，无需重新计算&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;二安装过程&#34;&gt;二、安装过程&lt;/h3&gt;&#xA;&lt;p&gt;用 &lt;a href=&#34;https://hub.docker.com/r/clickhouse/clickhouse-server/&#34;&gt;Docker&lt;/a&gt; 安装，过程相对简单。工业界在集群上装，比咱们这个复杂不少。&lt;/p&gt;&#xA;&lt;h4 id=&#34;1-配置-docker-镜像源&#34;&gt;1. 配置 Docker 镜像源&lt;/h4&gt;&#xA;&lt;p&gt;中国大陆地区下载镜像，需要配置镜像源。&lt;/p&gt;&#xA;&lt;p&gt;对于 Linux 系统，需要在 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt; 文件中配置镜像源（如下）。&lt;code&gt;Windows&lt;/code&gt; 和 &lt;code&gt;MacOS&lt;/code&gt; 系统更方便一点，可以直接在 &lt;code&gt;Docker Desktop&lt;/code&gt; 的 &lt;code&gt;Settings -&amp;gt; Docker Engine&lt;/code&gt; 页面修改 &lt;code&gt;daemon.json&lt;/code&gt; 文件。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
