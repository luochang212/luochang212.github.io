<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on Chang Luo</title>
    <link>http://luochang212.github.io/tags/python/</link>
    <description>Recent content in python on Chang Luo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 May 2019 21:43:09 +0100</lastBuildDate>
    
	<atom:link href="http://luochang212.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>PyQt5侧边栏布局</title>
      <link>http://luochang212.github.io/posts/pyqt5_layout_sidebar/</link>
      <pubDate>Fri, 10 May 2019 21:43:09 +0100</pubDate>
      
      <guid>http://luochang212.github.io/posts/pyqt5_layout_sidebar/</guid>
      <description>GitHub项目链接：pyqt5-demo
主流软件如网易云音乐、腾讯电脑管家，都有侧边栏。侧边栏能有效扩展应用空间，使软件功能的层次更加分明。
但PyQt5并没有一个专门的方法实现侧边栏。要实现侧边栏，主要有两种技术路线。一从用标签部件(QTabWidget)改造而来，二是用网格布局(QGridLayout)画出来。本文采用第一种技术路线，制作一个简单的侧边栏应用。
 Note: 两种技术路线制作的侧边栏有细微的差别。如果采用第二种技术路线(QGridLayout)，侧边栏和内容页之间没有明显的分界。所以需要额外地在侧边栏和内容页之间加一条线，来突出两者属于不同的组件。而第一种技术路线(QTabWidget)不需要，创建的侧边栏和内容页之间的区别明显。
下图是一个用第二种技术路线(QGridLayout)制作的应用，可以看到侧边栏和内容页中间画了一条线，以突出两个组件的分界。
 在开始写代码之前，我们先分析一下制作侧边栏需要几个步骤。
 添加部件 为部件设置布局 将标签部件改造成侧边栏的内容页 为侧边栏按钮编写函数，实现内容页之间的跳转  添加部件并设置布局 经过上述分析，我们明确了首先要有部件和基本布局，然后才能继续定义函数，完成我们的程序。关于部件和布局的基础知识，在上一篇博文中有介绍，详见PyQt5 布局浅析。
下面这段代码添加了部件且设置了布局。
from PyQt5.QtWidgets import * import sys class Window(QMainWindow): def __init__(self): super().__init__() # set the title of main window self.setWindowTitle(&#39;Sidebar layout - www.luochang.ink&#39;) # set the size of window self.Width = 800 self.height = int(0.618 * self.Width) self.resize(self.Width, self.height) # add all widgets self.btn_1 = QPushButton(&#39;1&#39;, self) self.btn_2 = QPushButton(&#39;2&#39;, self) self.</description>
    </item>
    
    <item>
      <title>PyQt5布局浅析</title>
      <link>http://luochang212.github.io/posts/pyqt5_layout/</link>
      <pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/pyqt5_layout/</guid>
      <description>GitHub项目链接：pyqt5-demo
制作一个简单的桌面应用大致可以分为三步，
 添加窗口小部件 设置部件布局 为部件添加功能  第一步添加部件很简单，认识部件名称即可，因此学习PyQt5, 应该从设置布局入手。
 Note: PyQt5是Python环境下用来开发UI界面的一个包。它容易上手，对初学者友好。并且拥有丰富的函数库，可以实现大部分桌面应用的开发需求。支持QSS语言，能够对界面风格做个性化调整。总而言之，PyQt5是一款开发效率极高的UI框架。
 创建第一个窗口 一般来说，桌面应用都以窗口(window)形式呈现。因此，搭建桌面应用的第一步是创建窗口。
下面这段代码创建了一个空的窗口。
from PyQt5.QtWidgets import * import sys class Window(QMainWindow): def __init__(self): super().__init__() # set the title of main window self.setWindowTitle(&#39;My first window - www.luochang.ink&#39;) # set the size of window self.Width = 500 self.height = int(0.618 * self.Width) self.resize(self.Width, self.height) if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) ex = Window() ex.show() sys.exit(app.exec_())  这段代码仅仅设置了窗口的标题和大小。</description>
    </item>
    
    <item>
      <title>微博数据可视化</title>
      <link>http://luochang212.github.io/posts/my_weibo/</link>
      <pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/my_weibo/</guid>
      <description>GitHub项目链接：weibo-analysis
这次的数据用的是本科期间就已经爬好，丢在硬盘里的数据。但因为raw data里夹杂着大量和博文无关的字符，当时没有足够的编程技巧处理数据，因此这一丢就是两年。本Python初丁趁着现在还有机会摸鱼，赶紧把数据翻出来，让它们发光发热。
文本获取 因为新浪微博的严防死打，现如今微博的数据越来越不好爬。GitHub上的微博爬虫生存周期通常都很短，使爬取数据的成本大大增加。这里我用的是微博@失眠狸 同学的方法，用鼠标精灵写了个插件，控制快捷键和页面拖动，把内容从浏览器上粘贴到sublime里。
生成csv文件 有了原始数据，接下来我们要把数据归一化，做成方便处理的数据。一个常用的方法就是将数据整理成csv文件。
Step 1. 分析需要保存的字段以及数据的维度，从而设计出数据的存储结构。根据原数据，我划分了五个字段: id, date, time, device, content, 它们分别记录一条微博的文件位置、发布日期、发布时间、发送设备和文本内容。
Step 2. 分割raw data. 先用split函数进行粗略分割，再用find函数精确分割。接着将分割好的内容提取到各字段，并依次存入csv。
经过上述两步，数据的整理工作就做完啦。
可视化微博数据 有了csv文件，做数据可视化是分分钟的事。此时我的工作平台从PyCharm搬到Jupyter Notebook，因为Jupyter Notebook可以制作的各式各样的可视化图表和窗口小工具(widget), 比PyCharm更适合数据处理。至于工具包，这里我选的是pandas和seaborn. 那么在可视化之前，看看我们对从中可能获取的信息，都有哪些期待。
首先是需求分析，我的目标如下:
 绘制日期分布热力图，观察今年使用微博频率的趋势
 绘制设备使用直方图，看看平时最常用什么平台发博
 绘制时间分布直方图，观察一天之中各时段的发博频率
 使用窗口滑块小部件，拖动查看各个时间段都发了什么内容
  这里没有过程描述，详见GitHub Repository.
分析结果如下:
热力图总的来说颜色逐年加深，说明我正在逐渐成为一个微博控。而且注意到往年年初我是不怎么玩微博的，但随着年纪渐长，1-3月份我玩微博的频率越来越高，这意味着过年可能越来越无聊，没有年味，从而加长了我混迹微博的时间。
是你吗？华为的舔狗~
晚上2点不睡的坏小孩，早上10点起的偷懒者。（此处是一个卑微的笑容）
附录：部分代码 下面这段代码分割了文本。
def classification(self, txt_array, file_index): id = np.array([]) date = np.array([]) time = np.array([]) device = np.array([]) content = np.array([]) count = 0 for ite in range(1, np.</description>
    </item>
    
    <item>
      <title>用Jupyter notebook规划旅行路线</title>
      <link>http://luochang212.github.io/posts/tsp_route/</link>
      <pubDate>Wed, 10 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/tsp_route/</guid>
      <description>GitHub项目链接：tsp-route
对于在欧洲的小伙伴们，复活节假在这一周就正式开始啦。大家都是怎么计划旅行的呢？
我的习惯是在出发前最后一晚，花上半小时，搜索目的地景点 (Point of interest, POI), 然后在Google Maps上为它们点上小星星，以免和它们插肩而过。我的地图经过一番操作，就成了下图这副这样。
此时此刻，望着这些密集的星星，我不禁自问：如何走最少的路，游遍所有景点呢?
找遍了谷歌和百度，没找到我要路径规划功能。最接近需求是谷歌的&amp;rdquo;Add destination&amp;rdquo;功能。然而这个功能只是依次连接你点选的地点。并不能通过一组地点，确定一条最短路径。
没有现成应用怎么办，我打算自己动手写一个。
适用模型：TSP 模型 一句话概括需求：我们需要一条从某地方出发，遍历所有地点，最终回到起点的最短路径。
学过运筹学的同学就发现了，这就是经典的旅行商问题，又名TSP问题。旅行商问题的确切描述是这样的：一个商人在各个城市之间旅行，要求遍历所有城市并返回到出发点，要如何规划路线，才能使总路径最短。（更多信息见维基百科)
解决思路  用googlemaps包获取纬度和经度信息 用OR-Tools包求解TSP问题 最后用gmaps可视化结果  在敲代码的过程中，最难的地方在于看文档查API, 搞清楚输入输出和调用结构。这是我第一次学习调API，一开始真是一头雾水。不过一顿代码敲完之后不禁感慨，GoogleI太为开发者着想了，调用API实现一个简单应用的代码量其实很小 orz
食用指南 项目地址 &amp;ndash;&amp;gt; 传送门
在运行代码之前，你需要以下配置：
 一个Jupyter Notebook. 推荐安装Anaconda3，Anaconda3自带Jupyter Notebook和全套Python依赖. 你还需要安装这些包：googleplaces, googlemaps, gmaps, ortools. 你需要一个Google Maps API key，点这里获取API.  完成配置等于成功的一半。在Jupyter notebook打开TSPSolver.ipynb，将第二个代码块的所有变量，改成自己的。比如自己的目的地和自己的API密码……最后从头到尾运行所有代码块，你就可以得到自己的旅行地图辣~
配置代码如下。
# input the places of interest (POI) places = &#39;YHA London Central Hostel&#39;, &#39;Coca-Cola London Eye&#39;, &#39;St. Paul\&#39;s Cathedral&#39;, &#39;Leadenhall Market&#39;, &#39;The National Gallery&#39; \ &#39;Big Ben&#39;, &#39;Buckingham Palace&#39;, &#39;Waterloo Station&#39; # the region Location=&#39;London&#39; # choose a mode Mode = &amp;quot;walking&amp;quot; # &amp;quot;driving&amp;quot;, &amp;quot;walking&amp;quot;, &amp;quot;bicycling&amp;quot;, &amp;quot;transit&amp;quot; # get Google API key from following website: # https://developers.</description>
    </item>
    
    <item>
      <title>Python解置换群问题</title>
      <link>http://luochang212.github.io/posts/python_math_problem/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>http://luochang212.github.io/posts/python_math_problem/</guid>
      <description>室友问我一个问题，把我难住了。
想不出解法，遂写了个程序暴力求解。
 题目：A permutation is applied to the string SUPERBGOLDHAT. The same permutation is applied to the output from this operation. The second output is OGTHLEPDSUARB. What was the first output? (Note: as an example, the permutation(1 3 4) applied to WOLF gives FOWL. Write your answer in capital letters inside quotation marks, e.g. &amp;ldquo;BEARDPLUGHOST&amp;rdquo;.)
 把它译成中文就是：一个置换作用于字符串时，会生成一个新字符串。已知将某个置换作用于字符串SUPERBGOLDHAT两次，生成字符串OGTHLEPDSUARB. 求该置换作用于字符串SUPERBGOLDHAT一次时，生成的结果。
 Note: 作用两次的意思就是，当一个置换规则作用于字符串一次时，会生成一个新字符串。将这个规则作用在这个新字符串上，又会生成一个字符串，这个字符串就是两次作用的结果。
 近世代数基础 如果你不知道什么是置换的话，可以看一下本节。学过近世代数的同学请自觉跳过这部分（否则就是没骨气）
我们给定一个序列$a ={1, 2, 3, 4, 5, 6} $ 。然后给定一个作用于该序列的置换：</description>
    </item>
    
  </channel>
</rss>